---
title: "Quantifying interactions between economics of climate change, the rest of economics and other disciplines"
author: ""
date: "`r format(Sys.time(), '%d/%m/%y')`"
output: 
  html_document:
    css: styles.css
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup, include=FALSE}
# Clean memory 
rm(list=ls())
gc()

# Load package
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, data.table, here, lubridate, ggmap, geosphere, stringr, gender, genderdata)

# List directories 
dir <- list()
dir$root <- here()
dir$figures <- here(dir$root, "Figures")
dir$tables <- here(dir$root, "Tables")
dir$raw.data <- here(dir$root, "Raw_data")
dir$prep.data <- here(dir$root, "Prepared_data")
# Create non existing directories
lapply(dir, function(i) dir.create(i, recursive = T, showWarnings = F))
```

# Preliminary data analysis

## Authorship data: gender and affiliation
Affiliation data `C1`and `RP` variables. We'd like to identify each countries in which authors of the articles are affiliated. Thus, we'd like to create a variable "country" which list each country referenced in the `C1`and `RP`variables. 

You can focus on climate related articles

```{r}
### First load data:
load(here(dir$prep.data,"Corpus_Short.Rdata"))
```

## Gender 

Creation of new columns for each author and for each article : separation of the column "AF" into several columns. New columns are entitled "auteur_" and goes from 1 to 10 (1 if there is only 1 author and 10 if there are 10 authors)

```{r}
Corpus.Short <- Corpus.Short %>%
  separate(col = AF, into = paste0("author_", 1:10), sep = ";", remove = FALSE, extra = "drop")
```

<span class ="comment">On a peut être besoin en amont de compter le nombre maximum d'auteur ? Car en créant 10 colonnes, il est possible que dans certains cas extrêmes on a plus d'auteurs et l'on rassemblerait allors dans la 10e colonnes tous ces auterus. On doit pouvoir compter le nombre de points virgules dans chaque observation de la variable AFG, et ainsi connaître le nombre maximum d'auteurs (et donc le nombre de colonnes à créer).</span>

Check to see if there are only missing values in one of the new column created

```{r}
results<- vector("logical", length = 10)

for (i in 1:10) {
  results[i] <- all(is.na(Corpus.Short[[paste0("author_", i)]]))
}

print(results)
```

<span class ="comment">Ce n'est pas évident de vérifier si notre spération avec le point virgule fonctionne de manière  systématique. Mais cela a l'air d'être pas mal ainsi</span>

Delete white spaces in the new columns created

```{r}
for (i in 1:10) {
  Corpus.Short[[paste0("author_", i)]] <- str_trim(Corpus.Short[[paste0("author_", i)]])
}
```

Delete parenthesis and figures in each columns created 

```{r}
for (i in 1:10) {
  Corpus.Short[[paste0("author_", i)]] <- gsub("\\s*\\([^\\)]+\\)", "", Corpus.Short[[paste0("author_", i)]])
}
```

Create a column for each last name and first name 

```{r}
for (i in 1:10) {
  Corpus.Short <- Corpus.Short %>%
    separate(col = paste0("author_", i), into = c(paste0("l_name_", i), paste0("f_name_", i)), sep = ",", remove = FALSE, extra = "drop")
}
```

<span class ="comment">Nickel tout ça!</span>

Delete white spaces in columns f_name 

```{r}
for (i in 1:10) {
  Corpus.Short[[paste0("f_name_", i)]] <- str_trim(Corpus.Short[[paste0("f_name_", i)]])
}
```

Dataframe for probabilities for gender 

<span class ="comment">Comment le package genderdata attribue-t-il une probabilité de genre à un prénom? J'imagine qu'il s'agit d'un algorithme qui est entraîné à partir d'un dictionnaire de prénom? Comment traite-t_il les valeurs de prénom qu'il ne connait pas? Comment les prénoms composés sont-ils compris par l'algorithme? Parfois nous avons des prénoms qui inclus juste une lettre du genre `John T.`, comment traite-t-il ce cas? </span>

```{r}
get_gender_prob <- function(first_name) {
  gender(first_name)
}

gender_proba <- lapply(Corpus.Short[, grepl("^f_name_", colnames(Corpus.Short))], get_gender_prob)

gender_proba_df <- do.call(rbind, gender_proba)
```


<span class ="comment">Ok! C'est super, on a bien avancé. Si je comprends bien, la commande get_gender_proba nous a donc  </span> 

Je fais quelques commandes ci-dessous pour comprendre:

```{r}
test1 = get_gender_prob(Corpus.Short$f_name_1)
length(unique(Corpus.Short$f_name_1))
# Test 1 contient plus de valeur qu'il n'y a de prénom "unique". Car il répète plusieurs fois le même prénom
length(unique(test1$name)) # Mais on a quand même beaucoup moins de prénoms différents dans test1; L'algorithme de la commange get_gender_prob doit donc associé des prénoms similaires entre eux
```

<span class ="comment">C'est vraiment pas mal! On a bien avancé, je pense que l'on a encore quelques nettoyages/compréhensions à préciser avant de pouvoir faire des statistiques descriptives mais c'est déjà bien. Une fois que l'on aura bien compris comment fonctionne ce calcule de probabilité, il va falloir que l'on assigne à chaque article sa "part" d'auteurs femmes. On pourra ensuite faire des statistiques descriptives (évolution par année, cas des articles CC vs autres articles d'économie, cas de ceertains journaux...)</span>

```{r}
# table(Corpus$CC)
table(Corpus.Short$CC)
```


## Citation data

### Clean citation data
Prepare citation data. We want to create a database, where for each article (one raw in `Corpus`), we have a data frame with its cited articles. (one raw by references). We want to separate information on the authors of the cited articles, the title of the article, the year of publication, and the journal. 

First work with one of the datasource: let's say Wos.

```{r}
gc()
load(here(dir$prep.data,"Wos_Short.Rdata"))
head(Wos.Econ.Short$CR)
```

Test

```{r}
table(is.na(Wos.Econ.Short$CR))
```

Test 2

```{r}
table(is.na(Wos.Econ.Short$CR), Wos.Econ.Short$PY)
```
